import { Match } from "../../../models/Match";
import { parse, format } from "date-fns";

import brazilianLocale from "date-fns/locale/pt-BR";

import * as constants from "../constants";

import {
  MatchEventSubType,
  MatchStageEnum,
  MinuteByMinute,
  MinuteByMinuteEvent,
} from "../../../models/uol/MinuteByMinute";

export const formatTodayMatch = (match: Match): string => {
  return `‚öΩ <b>${match.time1["nome-completo"]}</b> x <b>${match.time2["nome-completo"]}</b> √†s <b>${match.horario}</b> (Rodada: ${match.rodada})`;
};

export const formatMatchResult = (match: Match): string => {
  return `‚öΩ <b>${match.time1["nome-completo"]} ${match.placar1}</b> x <b>${match.placar2} ${match.time2["nome-completo"]}</b> (Rodada: ${match.rodada})`;
};

export const formatGroupedMatches = (title: string, content: string) => {
  const divider = `-`.repeat(title.length).split("").join(" ");
  let message = "";

  message += `${divider}\n`;
  message += `${title}\n`;
  message += `${divider}\n`;
  message += `${content}\n`;

  return message;
};

export const formatUpcomingMatch = (
  match: Match,
  shouldDisplayDate: boolean = false
): string => {
  const parsedDate = parse(match.data, constants.DATE_FORMAT, new Date());

  const matchDateAndDay = format(
    parsedDate,
    constants.OUTPUT_DATE_FORMAT_WITH_TIME,
    {
      locale: brazilianLocale,
    }
  );

  let message = "";

  message += `üì£ Rodada: ${match.rodada}\n`;
  message += `‚öΩ ${match.time1["nome-completo"]} x ${match.time2["nome-completo"]}\n`;
  message += `üìÜ ${
    shouldDisplayDate
      ? `${matchDateAndDay} √†s ${match.horario}`
      : `Hor√°rio: <b>${match.horario}</b>`
  }\n`;
  message += `üèüÔ∏è Est√°dio: ${match.estadio} (${match.local})\n`;

  return message;
};

const getMatchStageMessage = (
  stage: MatchStageEnum,
  timeline: MinuteByMinuteEvent
) => {
  let message = "";

  switch (stage) {
    case MatchStageEnum.EARLY_GAME:
      message = "Pr√© jogo";
      break;

    case MatchStageEnum.FIRST_HALF:
    case MatchStageEnum.SECOND_HALF:
      message = timeline["first-card"]
        ? `Autoriza o √°rbitro!`
        : `${timeline.minute}' do ${timeline["match-stage"]}¬∞ tempo`;
      break;

    case MatchStageEnum.INTERVAL:
      message = "Intervalo";
      break;

    case MatchStageEnum.ENDED:
    case MatchStageEnum.AFTER_GAME:
      message = "Fim de jogo!";
      break;
  }

  return message;
};

const formatEventText = (match: Match, event: MinuteByMinuteEvent) => {
  let message = "";
  const team = event.team === "home" ? match.time1 : match.time2 ?? undefined;

  switch (event.subtype) {
    case MatchEventSubType.GOAL:
      message += `‚ö†Ô∏è GOOOOOOOL! do ${team["nome-completo"]}!\n`;
      event.text && (message += `üìù ${event.text}`);
      break;

    case MatchEventSubType.TEXT:
      message = `üìù ${event.text}`;
      break;

    case MatchEventSubType.YELLOW_CARD:
      message += `üü® Cart√£o amarelo para o jogador do ${team["nome-completo"]}!\n`;
      message += `üìù ${event.text}`;
      break;

    case MatchEventSubType.RED_CARD:
      message += `üü• Cart√£o vermelho para o jogador do ${team["nome-completo"]}!\n`;
      message += `üìù ${event.text}`;
      break;

    case MatchEventSubType.SUBSTITUTION:
      message += `üîÑ Substitui√ß√£o no ${team["nome-completo"]}.`;
  }

  return message;
};

export const formatTimelineMessage = (match: Match, feed: MinuteByMinute) => {
  if (!feed) return;

  const timeline = feed.timeline[0];

  let message = "";

  message += `‚è∞ ${getMatchStageMessage(timeline["match-stage"], timeline)}\n`;
  message += `‚öΩ ${match.time1["nome-completo"]} ${feed.goals.home} x ${feed.goals.away} ${match.time2["nome-completo"]}\n`;
  message += `${formatEventText(match, timeline)}`;

  return message;
};

export const formatEndedMatch = (match: Match, feed: MinuteByMinute) => {
  let message = "";

  message += `‚ö†Ô∏è Esta partida j√° acabou!\n`;
  message += `üì£ Rodada: ${match.rodada}\n`;
  message += `‚öΩ ${match.time1["nome-completo"]} ${feed.goals.home} x ${feed.goals.away} ${match.time2["nome-completo"]}`;

  return message;
};

export const formatUnexpectedEndedMatch = (match: Match) => {
  let message = "";

  message += `‚ö†Ô∏è Esta partida ainda n√£o come√ßou ou n√£o est√° dispon√≠vel!\n`;
  message += `üì£ Rodada: ${match.rodada}\n`;
  message += `‚öΩ ${match.time1["nome-completo"]} x ${match.time2["nome-completo"]}`;

  return message;
};
